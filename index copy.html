<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>ESP32 Ultrasonic Radar â€“ FastÂ Edition (Bugâ€‘fix)</title>
    <style>
      :root {
        --bg: #0a0a0a;
        --ring: #222;
        --dot-rgb: 0, 255, 128;
        --cone-rgb: 0, 255, 0;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: var(--bg);
        color: #eee;
        font-family: system-ui, sans-serif;
        overflow: hidden;
      }
      #radar {
        display: block;
      }
      #overlay {
        position: fixed;
        top: 8px;
        left: 8px;
        font-size: 0.9rem;
        line-height: 1.4;
        pointer-events: auto;
      }
      #overlay span,
      label {
        display: block;
      }
      #clipLimit {
        width: 60px;
        margin-left: 4px;
      }
    </style>
  </head>
  <body>
    <canvas id="radar"></canvas>
    <div id="overlay">
      <span id="status">Connectingâ€¦</span>
      <span id="angle"></span>
      <span id="distance"></span>
      <label
        ><input type="checkbox" id="clipToggle" checked />Â Clip
        distancesÂ &gt;</label
      >
      <input
        type="number"
        id="clipLimit"
        value="300"
        min="10"
        max="1000"
        step="10"
      />Â cm
    </div>
    <script>
      /* === CONSTANTS & CACHED VALUES ============================================= */
      const DEFAULT_ESP_IP = "192.168.16.10";
      const WS_PORT = 8080;
      const RING_COUNT = 4;
      const CONE_HALF_DEG = 2;
      const RECONNECT_MS = 2000;
      const MAX_ECHO_PER_ANGLE = 2;

      const DOT_RGB = getComputedStyle(
        document.documentElement
      ).getPropertyValue("--dot-rgb");
      const CONE_RGB = getComputedStyle(
        document.documentElement
      ).getPropertyValue("--cone-rgb");
      const RING_COL = getComputedStyle(
        document.documentElement
      ).getPropertyValue("--ring");
      const LEVEL_ALPHA = [1, 0.55];

      /* === DOM ELEMENTS ========================================================== */
      const cvs = document.getElementById("radar");
      const ctx = cvs.getContext("2d");
      const st = document.getElementById("status");
      const angTxt = document.getElementById("angle");
      const distTxt = document.getElementById("distance");
      const clipTgl = document.getElementById("clipToggle");
      const clipInp = document.getElementById("clipLimit");

      /* === PRECOMPUTED TRIG TABLES ============================================== */
      const COS = new Float32Array(181),
        SIN = new Float32Array(181);
      for (let a = 0; a <= 180; a++) {
        const r = (a * Math.PI) / 180;
        COS[a] = Math.cos(r);
        SIN[a] = Math.sin(r);
      }

      /* === CANVAS GEOMETRY & RINGS ============================================== */
      let W,
        H,
        OX,
        OY,
        PX_PER_CM = 1;
      let furthest = 1; // <- moved above computeScale to avoid TDZ
      let RINGS_PATH = new Path2D();

      function computeScale() {
        PX_PER_CM = H / furthest;
      }

      function buildRings() {
        RINGS_PATH = new Path2D();
        for (let i = 1; i <= RING_COUNT; i++) {
          const r = (H * i) / RING_COUNT;
          RINGS_PATH.arc(OX, OY, r, Math.PI, 2 * Math.PI);
        }
      }

      function resize() {
        W = innerWidth;
        H = Math.min(innerHeight, W / 2);
        cvs.width = W;
        cvs.height = H;
        OX = W / 2;
        OY = H;
        buildRings();
        computeScale();
      }
      addEventListener("resize", resize);
      resize();

      /* === DATA ================================================================== */
      const echoes = Array.from({ length: 181 }, () => [null, null]);
      let currAngle = 0;

      function clipEnabled() {
        return clipTgl.checked;
      }
      function clipLimit() {
        return Number(clipInp.value) || 0;
      }
      function visible(d) {
        return !clipEnabled() || d <= clipLimit();
      }

      /* === DRAW LOOP ============================================================ */
      function draw() {
        ctx.clearRect(0, 0, W, H);

        // furthest visible echo
        furthest = 1;
        for (let a = 0; a <= 180; a++) {
          const d = echoes[a][0];
          if (d !== null && visible(d)) furthest = Math.max(furthest, d);
        }
        computeScale();

        ctx.save();
        ctx.beginPath();
        ctx.arc(OX, OY, H, Math.PI, 2 * Math.PI);
        ctx.clip();

        ctx.strokeStyle = RING_COL;
        ctx.lineWidth = 1;
        ctx.stroke(RINGS_PATH);

        ctx.fillStyle = `rgba(${CONE_RGB},0.15)`;
        ctx.beginPath();
        ctx.moveTo(OX, OY);
        const a1 = currAngle - CONE_HALF_DEG,
          a2 = currAngle + CONE_HALF_DEG;
        ctx.lineTo(OX + H * COS[a1], OY - H * SIN[a1]);
        ctx.lineTo(OX + H * COS[a2], OY - H * SIN[a2]);
        ctx.closePath();
        ctx.fill();

        for (let a = 0; a <= 180; a++) {
          const list = echoes[a];
          for (let i = 0; i < MAX_ECHO_PER_ANGLE; i++) {
            const d = list[i];
            if (d === null || !visible(d)) continue;
            ctx.fillStyle = `rgba(${DOT_RGB},${LEVEL_ALPHA[i]})`;
            const r = d * PX_PER_CM;
            ctx.beginPath();
            ctx.arc(OX + r * COS[a], OY - r * SIN[a], 3, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        ctx.restore();
        requestAnimationFrame(draw);
      }
      requestAnimationFrame(draw);

      /* === WEBSOCKET ============================================================ */
      function getIP() {
        const h = location.hostname;
        return !h || h === "localhost" || h === "127.0.0.1"
          ? DEFAULT_ESP_IP
          : h;
      }
      const ESP_IP = new URLSearchParams(location.search).get("ip") || getIP();
      let ws, retry;
      function connect() {
        ws = new WebSocket(`ws://${ESP_IP}:${WS_PORT}/`);
        st.textContent = "Connectingâ€¦";
        ws.onopen = () => (st.textContent = `ðŸŸ¢ Connected â†’ ${ESP_IP}`);
        ws.onclose = () => {
          st.textContent = "ðŸ”´ Disconnected â€“ retryingâ€¦";
          if (!retry)
            retry = setTimeout(() => {
              retry = null;
              connect();
            }, RECONNECT_MS);
        };
        ws.onerror = () => ws.close();
        ws.onmessage = ({ data }) => {
          try {
            const { angle, distance: d } = JSON.parse(data);
            if (typeof angle === "number" && typeof d === "number")
              pushEcho(angle | 0, Math.max(0, d));
          } catch {}
        };
      }
      connect();

      /* === STORE ECHO =========================================================== */
      function pushEcho(angle, d) {
        if (angle < 0 || angle > 180) return;
        const arr = echoes[angle];
        arr.unshift(d);
        if (arr.length > MAX_ECHO_PER_ANGLE) arr.length = MAX_ECHO_PER_ANGLE;
        currAngle = angle;
        angTxt.textContent = `AngleÂ ${angle}Â°`;
        distTxt.textContent = `DistanceÂ ${d.toFixed(1)}Â cm`;
      }
    </script>
  </body>
</html>
