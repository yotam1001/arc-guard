<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>ESP32 Ultrasonic Radar â€“ Improved Alarm Logic</title>
    <style>
      :root {
        --bg: #0a0a0a;
        --ring: #222;
        --dot-rgb: 0, 255, 128;
        --cone-rgb: 0, 255, 0;
        --move-rgb: 255, 0, 0;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: var(--bg);
        color: #eee;
        font-family: system-ui, sans-serif;
        overflow: hidden;
      }
      #radar {
        display: block;
      }
      #overlay {
        position: fixed;
        top: 8px;
        left: 8px;
        font-size: 0.9rem;
        line-height: 1.4;
        pointer-events: auto;
      }
      #clipLimit {
        width: 60px;
        margin-left: 4px;
      }
    </style>
  </head>
  <body>
    <canvas id="radar"></canvas>
    <div id="overlay">
      <span id="status">Connectingâ€¦</span>
      <span id="angle"></span>
      <span id="distance"></span>
      <label>
        <input type="checkbox" id="clipToggle" checked /> Clip distances >
      </label>
      <input
        type="number"
        id="clipLimit"
        value="300"
        min="10"
        max="1000"
        step="10"
      />
      cm
    </div>
    <audio
      id="alarmSound"
      src="https://www.soundjay.com/button/sounds/beep-07.mp3"
    ></audio>

    <script>
      /* === CONSTANTS & SETTINGS === */
      const DEFAULT_ESP_IP = "192.168.22.120";
      const WS_PORT = 8080;
      const MAX_ECHO_PER_ANGLE = 2;
      const MOVEMENT_THRESHOLD_CM = 20;
      const REQUIRED_MOVING_POINTS = 3;
      const ALARM_DURATION_MS = 3000;
      const DISTANCE_THRESHOLD = 50; // cm difference considered "drastic"

      const DOT_RGB = getComputedStyle(
        document.documentElement
      ).getPropertyValue("--dot-rgb");
      const MOVE_RGB = getComputedStyle(
        document.documentElement
      ).getPropertyValue("--move-rgb");
      const RING_COL = getComputedStyle(
        document.documentElement
      ).getPropertyValue("--ring");
      const LEVEL_ALPHA = [1, 0.55];
      const sweepOpacity = 0.7;

      /* === DOM ELEMENTS === */
      const cvs = document.getElementById("radar");
      const ctx = cvs.getContext("2d");
      const st = document.getElementById("status");
      const angTxt = document.getElementById("angle");
      const distTxt = document.getElementById("distance");
      const clipTgl = document.getElementById("clipToggle");
      const clipInp = document.getElementById("clipLimit");
      const alarmSound = document.getElementById("alarmSound");

      /* === CANVAS GEOMETRY === */
      let W,
        H,
        OX,
        OY,
        PX_PER_CM = 1;
      let furthest = 1;
      let RINGS_PATH = new Path2D();
      const COS = new Float32Array(181);
      const SIN = new Float32Array(181);

      for (let a = 0; a <= 180; a++) {
        const r = (a * Math.PI) / 180;
        COS[a] = Math.cos(r);
        SIN[a] = Math.sin(r);
      }

      function resize() {
        W = innerWidth;
        H = Math.min(innerHeight, W / 2);
        cvs.width = W;
        cvs.height = H;
        OX = W / 2;
        OY = H;
        buildRings();
      }

      function buildRings() {
        RINGS_PATH = new Path2D();
        for (let i = 1; i <= 4; i++) {
          const r = (H * i) / 4;
          RINGS_PATH.arc(OX, OY, r, Math.PI, 2 * Math.PI);
        }
      }
      addEventListener("resize", resize);
      resize();

      /* === DATA & FLAGS === */
      const echoes = Array.from({ length: 181 }, () => [null, null]);
      const previousEchoes = Array.from({ length: 181 }, () => [null, null]);
      const movedFlags = new Array(181).fill(false);

      let currAngle = 0;
      let lastAngle = 0;
      let fullRotations = 0;

      let capturingBaseline = true;
      let baselineCaptured = false;
      let alarmActive = false;
      let alarmTriggered = false;

      /* === HELPER FUNCTIONS === */
      function clipEnabled() {
        return clipTgl.checked;
      }
      function clipLimit() {
        return Number(clipInp.value) || 0;
      }
      function visible(d) {
        return !clipEnabled() || d <= clipLimit();
      }

      /* === ALARM SYSTEM === */
      function triggerAlarm() {
        if (alarmActive) return;

        alarmActive = true;
        alarmTriggered = true;
        alarmSound.play();
        st.textContent = "ðŸš¨ Movement detected! Alarm triggered.";

        setTimeout(() => {
          alarmSound.pause();
          alarmSound.currentTime = 0;
          alarmActive = false;
          capturingBaseline = true; // reset baseline after alarm
          baselineCaptured = false;
          st.textContent = "Baseline reset after alarm.";
        }, ALARM_DURATION_MS);
      }

      function checkMovement() {
        if (!baselineCaptured || alarmTriggered) return;

        let movedPoints = 0;
        for (let i = 0; i <= 180; i++) {
          movedFlags[i] = false;
          const [old0, old1] = previousEchoes[i];
          const [new0, new1] = echoes[i];

          if (
            old0 !== null &&
            new0 !== null &&
            Math.abs(new0 - old0) > MOVEMENT_THRESHOLD_CM
          ) {
            movedFlags[i] = true;
            movedPoints++;
          } else if (
            old1 !== null &&
            new1 !== null &&
            Math.abs(new1 - old1) > MOVEMENT_THRESHOLD_CM
          ) {
            movedFlags[i] = true;
            movedPoints++;
          }
        }

        console.log(`Moved points: ${movedPoints}`);
        if (movedPoints >= REQUIRED_MOVING_POINTS) {
          triggerAlarm();
        }
      }

      /* === UPDATED DRAW FUNCTION === */
      function draw() {
        ctx.clearRect(0, 0, W, H);

        furthest = 1;
        for (let a = 0; a <= 180; a++) {
          const d = echoes[a][0];
          if (d !== null && visible(d)) furthest = Math.max(furthest, d);
        }
        PX_PER_CM = H / furthest;

        ctx.save();
        ctx.beginPath();
        ctx.arc(OX, OY, H, Math.PI, 2 * Math.PI);
        ctx.clip();

        // Draw rings
        ctx.strokeStyle = RING_COL;
        ctx.stroke(RINGS_PATH);

        // Draw echoes
        for (let a = 0; a <= 180; a++) {
          const data = echoes[a];
          for (let i = 0; i < MAX_ECHO_PER_ANGLE; i++) {
            const d = data[i];
            if (d === null || !visible(d)) continue;
            ctx.fillStyle = movedFlags[a]
              ? `rgba(${MOVE_RGB},${LEVEL_ALPHA[i]})`
              : `rgba(${DOT_RGB},${LEVEL_ALPHA[i]})`;
            const r = d * PX_PER_CM;
            ctx.beginPath();
            ctx.arc(OX + r * COS[a], OY - r * SIN[a], 3, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // === Draw the sweeping radar line ===
        ctx.strokeStyle = `rgba(${MOVE_RGB},${sweepOpacity})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(OX, OY);
        ctx.lineTo(OX + H * COS[currAngle], OY - H * SIN[currAngle]);
        ctx.stroke();

        // === Drastic alarm visual ===
        if (alarmActive) {
          ctx.fillStyle = "rgba(255, 0, 0, 0.3)"; // semi-transparent red flash
          ctx.fillRect(0, 0, W, H);
          ctx.fillStyle = "white";
          ctx.font = "bold 48px system-ui, sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("ðŸš¨ ALARM!", W / 2, H / 2);
        }

        ctx.restore();
        requestAnimationFrame(draw);
      }
      requestAnimationFrame(draw);

      /* === WEBSOCKET === */
      function getIP() {
        const h = location.hostname;
        return !h || h === "localhost" || h === "127.0.0.1"
          ? DEFAULT_ESP_IP
          : h;
      }
      const ESP_IP = new URLSearchParams(location.search).get("ip") || getIP();

      let ws;
      function connect() {
        ws = new WebSocket(`ws://${ESP_IP}:${WS_PORT}/`);
        st.textContent = "Connectingâ€¦";

        ws.onopen = () => (st.textContent = `ðŸŸ¢ Connected â†’ ${ESP_IP}`);
        ws.onclose = () => {
          st.textContent = "ðŸ”´ Disconnected â€“ retryingâ€¦";
          setTimeout(connect, 2000);
        };
        ws.onmessage = ({ data }) => {
          try {
            const { angle, distance } = JSON.parse(data);
            pushEcho(angle | 0, Math.max(0, distance));
          } catch {}
        };
      }
      connect();

      /* === STORE ECHO === */
      function pushEcho(angle, distance) {
        if (angle < 0 || angle > 180) return;

        const arr = echoes[angle];
        arr.unshift(distance);
        if (arr.length > MAX_ECHO_PER_ANGLE) arr.length = MAX_ECHO_PER_ANGLE;

        currAngle = angle;
        angTxt.textContent = `Angle ${angle}Â°`;
        distTxt.textContent = `Distance ${distance.toFixed(1)} cm`;

        // Detect full rotation (angle wrap-around)
        if (lastAngle > angle) {
          fullRotations++;
          alarmTriggered = false;

          if (!baselineCaptured && !capturingBaseline) capturingBaseline = true;
        }
        lastAngle = angle;

        if (capturingBaseline) {
          // Capture baseline after full rotation
          if (angle === 180) {
            for (let i = 0; i <= 180; i++) {
              previousEchoes[i][0] = echoes[i][0];
              previousEchoes[i][1] = echoes[i][1];
            }
            baselineCaptured = true;
            capturingBaseline = false;
            st.textContent = "âœ… Baseline captured.";
          }
        } else {
          checkMovement();
        }
      }
    </script>
  </body>
</html>
