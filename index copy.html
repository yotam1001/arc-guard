<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>ESP32 Ultrasonic Radar â€“ Rangeâ€‘Clip & Twoâ€‘Echo</title>
    <style>
      :root {
        --bg: #0a0a0a;
        --ring: #222;
        --dot-rgb: 0, 255, 128;
        --cone-rgb: 0, 255, 0;
      }
      html,
      body {
        margin: 0;
        height: 100%;
        background: var(--bg);
        color: #eee;
        font-family: system-ui, sans-serif;
        overflow: hidden;
      }
      #radar {
        display: block;
        background: transparent;
        touch-action: none;
      }
      #overlay {
        position: fixed;
        top: 8px;
        left: 8px;
        font-size: 0.9rem;
        line-height: 1.4;
        pointer-events: auto;
      }
      #overlay span,
      label {
        display: block;
      }
      #clipLimit {
        width: 60px;
        margin-left: 4px;
      }
    </style>
  </head>
  <body>
    <canvas id="radar"></canvas>
    <div id="overlay">
      <span id="status">Connectingâ€¦</span>
      <span id="angle"></span>
      <span id="distance"></span>
      <label
        ><input type="checkbox" id="clipToggle" checked />Â Clip
        distancesÂ &gt;</label
      >
      <input
        type="number"
        id="clipLimit"
        value="300"
        min="10"
        max="1000"
        step="10"
      />Â cm
    </div>
    <script>
      /* === CONFIG ================================================================ */
      const DEFAULT_ESP_IP = "192.168.1.45";
      const WS_PORT = 8080;
      const RING_COUNT = 4;
      const CONE_HALF_DEG = 2;
      const RECONNECT_MS = 2000;
      const MAX_ECHO_PER_ANGLE = 2; // keep only current + previous

      /* === DOM ================================================================ */
      const cvs = document.getElementById("radar");
      const ctx = cvs.getContext("2d");
      const stTxt = document.getElementById("status");
      const angTxt = document.getElementById("angle");
      const distTxt = document.getElementById("distance");
      const clipToggle = document.getElementById("clipToggle");
      const clipLimitInput = document.getElementById("clipLimit");

      /* === cached colours === */
      const DOT_RGB = getComputedStyle(
        document.documentElement
      ).getPropertyValue("--dot-rgb");
      const CONE_RGB = getComputedStyle(
        document.documentElement
      ).getPropertyValue("--cone-rgb");
      const RING_COLOR = getComputedStyle(
        document.documentElement
      ).getPropertyValue("--ring");

      /* === geometry === */
      let ORIGIN_X,
        ORIGIN_Y,
        PX_PER_CM = 1;
      function resizeCanvas() {
        const W = innerWidth;
        const H = Math.min(innerHeight, W / 2);
        cvs.width = W;
        cvs.height = H;
        ORIGIN_X = W / 2;
        ORIGIN_Y = H;
      }
      addEventListener("resize", resizeCanvas);
      resizeCanvas();

      /* === data === */
      const echoes = new Map();
      let currentAngle = 0;
      let furthestCm = 1;

      function computeScale() {
        PX_PER_CM = cvs.height / furthestCm;
      }

      /* === helpers === */
      function clipEnabled() {
        return clipToggle.checked;
      }
      function clipLimit() {
        return Number(clipLimitInput.value) || 0;
      }
      function isVisible(dist) {
        return !clipEnabled() || dist <= clipLimit();
      }

      /* === draw === */
      function draw() {
        ctx.clearRect(0, 0, cvs.width, cvs.height);

        // recompute furthest visible distance each frame
        furthestCm = 1;
        echoes.forEach((a) => {
          if (a.length) {
            const d = a[0].d;
            if (isVisible(d)) furthestCm = Math.max(furthestCm, d);
          }
        });
        computeScale();

        ctx.save();
        ctx.beginPath();
        ctx.arc(ORIGIN_X, ORIGIN_Y, cvs.height, Math.PI, 2 * Math.PI);
        ctx.clip();

        // rings
        ctx.strokeStyle = RING_COLOR;
        ctx.lineWidth = 1;
        for (let i = 1; i <= RING_COUNT; i++) {
          const r = (cvs.height * i) / RING_COUNT;
          ctx.beginPath();
          ctx.arc(ORIGIN_X, ORIGIN_Y, r, Math.PI, 2 * Math.PI);
          ctx.stroke();
        }

        // cone
        ctx.fillStyle = `rgba(${CONE_RGB},0.15)`;
        const a1 = ((currentAngle - CONE_HALF_DEG) * Math.PI) / 180;
        const a2 = ((currentAngle + CONE_HALF_DEG) * Math.PI) / 180;
        ctx.beginPath();
        ctx.moveTo(ORIGIN_X, ORIGIN_Y);
        ctx.lineTo(
          ORIGIN_X + cvs.height * Math.cos(a1),
          ORIGIN_Y - cvs.height * Math.sin(a1)
        );
        ctx.lineTo(
          ORIGIN_X + cvs.height * Math.cos(a2),
          ORIGIN_Y - cvs.height * Math.sin(a2)
        );
        ctx.closePath();
        ctx.fill();

        // dots: newest strong, previous dimmer
        const levels = [1, 0.5];
        echoes.forEach((arr) => {
          arr.forEach((e, idx) => {
            if (idx >= levels.length) return;
            if (!isVisible(e.d)) return;
            ctx.fillStyle = `rgba(${DOT_RGB},${levels[idx]})`;
            const r = e.d * PX_PER_CM;
            const aRad = (e.angle * Math.PI) / 180;
            ctx.beginPath();
            ctx.arc(
              ORIGIN_X + r * Math.cos(aRad),
              ORIGIN_Y - r * Math.sin(aRad),
              3,
              0,
              Math.PI * 2
            );
            ctx.fill();
          });
        });

        ctx.restore();
        requestAnimationFrame(draw);
      }
      requestAnimationFrame(draw);

      /* === websocket === */
      function detectIP() {
        const h = location.hostname;
        return !h || h === "localhost" || h === "127.0.0.1"
          ? DEFAULT_ESP_IP
          : h;
      }
      const ESP_IP =
        new URLSearchParams(location.search).get("ip") || detectIP();
      let ws, retry;
      function connect() {
        ws = new WebSocket(`ws://${ESP_IP}:${WS_PORT}/`);
        stTxt.textContent = "Connectingâ€¦";
        ws.onopen = () => (stTxt.textContent = `ðŸŸ¢ Connected â†’ ${ESP_IP}`);
        ws.onerror = () => ws.close();
        ws.onclose = () => {
          stTxt.textContent = "ðŸ”´ Disconnected â€“ retryingâ€¦";
          if (!retry)
            retry = setTimeout(() => {
              retry = null;
              connect();
            }, RECONNECT_MS);
        };
        ws.onmessage = ({ data }) => {
          try {
            const { angle, distance } = JSON.parse(data);
            if (typeof angle === "number" && typeof distance === "number")
              storeEcho(Math.round(angle), Math.max(0, distance));
          } catch {}
        };
      }
      connect();

      /* === echo buffer === */
      function storeEcho(angle, dist) {
        let arr = echoes.get(angle);
        if (!arr) {
          arr = [];
          echoes.set(angle, arr);
        }
        arr.unshift({ angle, d: dist });
        if (arr.length > MAX_ECHO_PER_ANGLE) arr.length = MAX_ECHO_PER_ANGLE;
        currentAngle = angle;
        angTxt.textContent = `AngleÂ ${angle}Â°`;
        distTxt.textContent = `DistanceÂ ${dist.toFixed(1)}Â cm`;
      }
    </script>
  </body>
</html>
